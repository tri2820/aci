#!/bin/sh
# Usage: source aci
# ACI Arduino Client Interface 0.1
# ACI needs arduino-cli, grep, jq installed on your linux machine

PROJECT_DIR="$PWD"
PROJECT_FOLDER="${PWD##*/}"
PROJECT_NAME="$PROJECT_FOLDER"
DEBUG_MODE=false
DEBUG_FLAG=""
YML_PATH="$PROJECT_DIR/$PROJECT_NAME.yml"
THIS="$(realpath $BASH_SOURCE)"

HEAD="\e[48;5;125m"
TAIL="\e[0m"

# name of main .ino file is the same as project's folder name
MAIN="$PROJECT_NAME.ino"

if [[ -n "$PS1_BAK" ]]; then
  PS1="$PS1_BAK"
else
  PS1_BAK="$PS1"
fi

function deactivate {
    printf 'Exit arduino env\n'
    PS1="$PS1_BAK"
    exec bash
}

# -----------------ALIASES--------------------

alias setup_uno_ACM0="setup arduino:avr:uno /dev/ttyACM0"
alias reload_global='deactivate | printf "\n" && ". aci_env'
alias reload='deactivate | printf "\n" && . $THIS'
alias install_this="sudo cp $THIS /usr/local/bin && printf 'Copied $THIS to /usr/local/bin\n\x27aci\x27 is now global!\nUse \x27source aci\x27 to activate Arduino environment!\n'"

# -----ARDUINO-CLI INDEPENDENT UTILITIES----

# Project's states
function check_setup {
    if  ! [[ $FQBN ]]; then
        if [[ $1 ]]; then 
            eval $1=false
        fi
        if [[ $2 ]]; then 
            eval "$2='FQBN is missing, try to set with \x27setup\x27'"
        fi
        return
    fi

    if ! [[ $PORT ]]; then
        if [[ $1 ]]; then 
            eval $1=false
        fi
        if [[ $2 ]]; then 
            eval "$2='PORT is missing, try to set with \x27setup\x27'"
        fi
        return
    fi

    if [[ $1 ]]; then     
        eval $1=true
    fi

    if [[ $2 ]]; then
        eval "$2='Found FQBN and PORT'"
    fi
    return
}

function gen_prompt {
    check_setup SETUP;
    if $SETUP ; then
        local SETUP_STR="| $FQBN | $PORT"
    else
        local SETUP_STR="*not setup*"
    fi

    if $DEBUG_MODE  ; then
        local DEBUG_STR="| debugging"
    else
        local DEBUG_STR=""
    fi

    ARDUINO_PROMPT="$HEAD$PROJECT_NAME $SETUP_STR $DEBUG_STR$TAIL"
    PS1="\n$ARDUINO_PROMPT\n   |$PS1_BAK"   
}


function debug {
    if [[ $1 = false ]]; then
        DEBUG_MODE=false
        DEBUG_FLAG=""
    else 
        DEBUG_MODE=true
        DEBUG_FLAG="--debug"
    fi

    gen_prompt
}

# UI Customize
function change_color {
    re='^[0-9]+$'

    if [[ "$1" =~ $re && "$1" -ge 0 && "$1" -le 255 ]]; then
        HEAD="\e[48;5;$1m"
        gen_prompt
        return
    fi

    printf "Color cant be changed to $1\n"
}


# File handling
function new {
    if [ -f "$PWD/$1" ]; then
        if [[ $2 ]]; then
            eval $2=false
        fi

        if [[ $3 ]]; then
            eval "$3='Found $PWD/$1'"
        fi
        return
    fi

    touch "$PWD/$1";
    printf "void setup() {\n\n}\n\nvoid loop() {\n\n}" >> "$PWD/$1";
    if [[ $2 ]]; then
        eval $2=true
    fi
    if [[ $3 ]]; then
        eval "$3='Created $1 at $PWD'"
    fi
    return
}

# YML 
function gen_project_yml {
    if [[ -f $YML_PATH ]]; then
        if [[ $1 ]]; then
            eval $1=false
        fi

        if [[ $2 ]]; then
            eval "$2='Found $PROJECT_DIR/$PROJECT_NAME.yml'"
        fi
        return
    fi

    touch $YML_PATH
    printf "# This file is generated by Arduino Client Interface (ACI).\n# More about project ACI: https://github.com/tri2820/aci\nproxy_type: auto\nsketchbook_path: .\narduino_data: /root/.arduino15\nboard_manager: null\n" >> $YML_PATH

    if [[ $1 ]]; then
        eval $1=true
    fi

    if [[ $2 ]]; then
        eval "$2='Created $PROJECT_NAME.yml at $PROJECT_DIR'"
    fi
    return
    
}

function get_project_yml_flag {
    # This flag is returned dynamically because users can remove yml file on their own
    # get_project_yml_flag SUCCESS MSG YML_FLAG
    if [[ -f $YML_PATH ]]; then
        if [[ $1 ]]; then
            eval $1=true
        fi

        if [[ $2 ]]; then
            eval "$2='Found $YML_PATH\n    use as this project\x27s config'"
        fi


        if [[ $3 ]]; then   
            eval "$3=' --config-file $YML_PATH'"
        fi
        return
    fi
    
    if [[ $1 ]]; then
        eval $1=false
    fi
    if [[ $2 ]]; then
        eval "$2='WARNING: no $YML_PATH file'"
    fi
    if [[ $3 ]]; then   
        eval $3=''
    fi
}

function read_project_yml {
    get_project_yml_flag SUCCESS;
    if [[ SUCCESS = true ]]; then
        if [[ $1 ]]; then
            local value="$(grep -oP "$1\s*:\s*\K(.*)" $YML_PATH)"
        else
            printf "Usage: read_project_yml <key>\n" 
            return
        fi

        if [[ -d $value ]]; then 
            # Turns paths to absolute paths with respect to $PROJECT_DIR 
            abs_path="$(cd "$PROJECT_DIR" && realpath "$value")"
            printf "$abs_path"
        else
            printf "$value"
        fi
    fi
}


# Distribute
function freeze {

    local libs_info=$(libs json | jq -r '.libraries[] | .library | "{\"name\" : \"\(.Name)\", \"version\" : \"\(.Version)\", \"url\" : \"\(.Properties.url)\", \"location\" : \"\(.InstallDir)\"}"')
    local ARDUINO_DATA_DIR=$(read_project_yml arduino_data)


    while read -r line; do 
        # Convert location to relative location
        local name=$(printf "$line" | jq .name | grep -oP '^"\K(.*)(?="$)')
        local version=$(printf "$line" | jq .version | grep -oP '^"\K(.*)(?="$)')
        local url=$(printf "$line" | jq .url | grep -oP '^"\K(.*)(?="$)')
        local location=$(printf "$line" | jq .location | grep -oP '^"\K(.*)(?="$)')


        if [[ "$location" == "$ARDUINO_DATA_DIR"* ]]; then
            local rel_location="<arduino_data>/packages/arduino/hardware/<FQBN_FAMILY>/<ARDUINO_CLI VERSION>/libraries/"
        else
            local rel_location="sketchbook/libraries/"
        fi

        # Make lib info
        local lib_info="$name@$version | $rel_location | $url"
        printf "$lib_info\n"
    done <<< "$libs_info"
}

function clean {
    local count=`ls -1 *.hex 2>/dev/null | wc -l`
    if [[ $count != 0 ]]; then sudo rm "$PROJECT_DIR"/*.hex; fi
    local count=`ls -1 *.elf 2>/dev/null | wc -l`
    if [[ $count != 0 ]]; then sudo rm "$PROJECT_DIR"/*.elf; fi
}

function distribute {
    freeze > "requirements.txt"
    # Smarter distribute
    zip "$PROJECT_DIR/$PROJECT_NAME.zip" "$PROJECT_DIR"/* 
}

function serial_read {
    if [[ $2 ]]; then
        stty -F "$1" "$2"
        cat "$1"
    fi

    if [[ $1 ]]; then 
        if [[ $PORT ]]; then
            stty -F "$PORT" "$1"
            cat "$PORT"
        else
            printf "No port is specified, you need to setup first!\n"
        fi
    else
        printf "Usage: serial_read <port> <baudrate>\n"
    fi
}

function parse_help {
    if [[ $1 ]]; then
        if [[ $2 ]]; then
            eval $2='$(printf "$1" | grep -oP "^\K(.+)(?=\s+:\s+.+\s+:\s+.+$)")'
        fi

        if [[ $3 ]]; then
            eval $3='$(printf "$1" | grep -oP "^.+\s+:\s+\K(.+)(?=\s+:\s+.+$)")'
        fi

        if [[ $4 ]]; then
            eval $4='$(printf "$1" | grep -oP "^.+\s+:\s+.+\s+:\s+\K(.+)$")'
        fi
    fi
} 

function help {

    local helps=$(grep -oP "\s*#@\s\K$1(.*)" "$THIS")
   
    while read -r help; do
        parse_help "$help" NAME USAGE DESCRIPTION
        printf "$NAME\n    Usage: $DESCRIPTION\n    $USAGE\n"
    done <<< "$helps"
    

    # HELP 
    #@ help : help <keyword> : Return usages of functions which are found with <keyword>
    #@ update : update : Update arduino-cli index file
    #@ deactivate : deactivate : Exit the environment
    #@ setup : setup <fqbn> <port> : Set FQBN and PORT, fqbn_install FQBN, create PROJECT_NAME.ino 
    #@ serial_read :  serial_read <port> <baudrate> or serial_read PORT <baudrate> if PORT was set : Return values sending to <port> at <baudrate>
    #@ new : new <filename> SUCCESS MSG : Create <filename>.ino and assign (true | false), respective message depends on if <filename>.ino was created
    #@ compile : compile : compile PROJECT_NAME.ino 
    #@ upload : upload : compile PROJECT_NAME.ino and upload it's executable file to FQBN at PORT
    #@ libs : libs : Return list of installed libraries
    #@ lib_clone : lib_clone <url> or lib_clone <url> <name> : git clone respository at <url> to PROJECT_DIR/libraries/<name>
    #@ lib_search : lib_search <keyword> : Return list of libraries found online with <keyword>
    #@ lib_install : lib_install <name> : Install library named <name> at PROJECT_DIR/libraries
    #@ lib_remove : lib_remove <name> : Remove library named <name> at PROJECT_DIR/libraries
    #@ boards : boards : Return list of connected Arduino boards 

    #@ freeze : freeze : Return all project's dependecies
    #@ clean : clean : Clean project's installing and compiling junk 
    #@ distribute : distribute : Compress the whole project into one single package for distribution
    #@ debug : debug (true | false) : Change the debugging status of the project

    #@ check_setup : check_setup SUCCESS MSG :  Assign (true | false) and a respective message depends on if the project is setup
    #@ fqbns : fqbns : Return list of installed fqbns
    #@ fqbn_install : fqbn_install <fqbn_family> or fqbn_install <fqbn> : Extract <fqbn_family>, install and prepare config for <fqbn_family>

    #@ gen_project_yml : gen_project_yml SUCCESS MSG : Generate PROJECT_NAME.yml and assign (true | false), respective message depends on if PROJECT_NAME.yml was created
    #@ get_project_yml_flag : get_project_yml_flag SUCCESS MSG FLAG : Assign (true | false), respective message depends on if PROJECT_NAME.yml was found, arduino-cli custom config-file flag 
    #@ read_project_yml : read_project_yml <key> : Return the value of <key> in PROJECT_NAME.yml
    
    #@ gen_prompt : gen_prompt : Change PS1 depends on the project's status
    #@ change_color : change_color <color_int> : Set PS1's panel background color using <color_int> , 0 <= <color_int> <= 255
}

# ----------------ARDUINO-CLI INTERFACE----------

# Generic
function update {
    get_project_yml_flag SUCCESS MSG YML_FLAG
    sudo arduino-cli $DEBUG_FLAG $YML_FLAG core update-index;
}

# Board
function boards {
    get_project_yml_flag SUCCESS MSG YML_FLAG
    sudo arduino-cli $DEBUG_FLAG $YML_FLAG board list;
}

function fqbns {
    get_project_yml_flag SUCCESS MSG YML_FLAG
    if [[ "$1" == "json" ]]; then
        local json_flag="--format json"
    else 
        local json_flag=""
    fi

    sudo arduino-cli $json_flag $DEBUG_FLAG $YML_FLAG core list;
}

function fqbn_install {
    get_project_yml_flag SUCCESS MSG YML_FLAG
    printf "Installing FQBN $FQBN_manufacture_family\n"
    sudo arduino-cli $DEBUG_FLAG $YML_FLAG core install "$1"
}

# Code
function compile {
    check_setup SETUP MSG;
    if $SETUP ; then
        get_project_yml_flag SUCCESS MSG YML_FLAG
        sudo arduino-cli $DEBUG_FLAG $YML_FLAG compile --fqbn "$FQBN" "$PROJECT_DIR";
    else
        printf "$MSG\n";
    fi
}

function upload {
    check_setup SETUP MSG;
    if $SETUP ; then
        get_project_yml_flag SUCCESS MSG YML_FLAG
        compile;
        sudo arduino-cli upload $DEBUG_FLAG $YML_FLAG -p $PORT --fqbn "$FQBN" "$PROJECT_DIR";
        printf "Upload completed\n"
    else
        printf "$MSG\n"
    fi
}

# package manager
function lib_clone {
    local SK_LIB_DIR="$(read_project_yml sketchbook_path)/libraries"

    if ! [[ -d "$SK_LIB_DIR" ]]; then
        mkdir "$SK_LIB_DIR" && printf "No libraries folder in $(read_project_yml sketchbook_path), aci created one\n"
    fi

    if [[ $1 ]]; then
        if [[ $2 ]]; then 
            git clone "$1" "$SK_LIB_DIR/$2"
        else
            (cd "$SK_LIB_DIR" && git clone "$1")
        fi
    fi 
}

function lib_search {
    if [[ $1 ]]; then
        get_project_yml_flag SUCCESS MSG YML_FLAG
        sudo arduino-cli $DEBUG_FLAG $YML_FLAG lib search "$1"
    fi
}

function lib_install {
    get_project_yml_flag SUCCESS MSG YML_FLAG
    sudo arduino-cli $DEBUG_FLAG $YML_FLAG lib install "$1"
}

function lib_remove {
    get_project_yml_flag SUCCESS MSG YML_FLAG
    sudo arduino-cli $DEBUG_FLAG $YML_FLAG lib uninstall "$1"
}

function libs {
    if [[ $1 == "json" ]]; then
        local JSON_FLAG="--format json" 
    fi

    get_project_yml_flag SUCCESS MSG YML_FLAG
    sudo arduino-cli $DEBUG_FLAG $YML_FLAG $JSON_FLAG lib list --all;
}

# ------ARDUINO-CLI DEPENDENT UTILITIES-----------------
function setup {
    # TODO: check legit FQBN and legit port
    if [[ $2 ]]; then
        FQBN="$1"
        FQBN_FAMILY=$(printf "$FQBN" | grep -oP "\w+:\K(\w+)(?=:\w+)")
        FQBN_manufacture_family=$(echo "$FQBN"| grep -oP "\w+:\w+")

        PORT="$2"
        gen_prompt

        new $MAIN SUCCESS MSG
        printf "$MSG\n"
        
        # Catch Arduino-cli error, further analyzing required
        local fqbn_installed='$(fqbns json | grep -oP "\K(arduino:avr)")'
        if [[ $fqbn_installed ]]; then 
            printf "Found $FQBN_manufacture_family config"
        else
            fqbn_install "$FQBN_manufacture_family"
        fi

    else
        printf "Usage: setup <core> <port>\n"
    fi
}

# ---------ON ACTIVATION----------

if [[ "$1" == "install" ]]; then
    install_this
    deactivate
fi

gen_prompt
printf "$HEAD## Welcome to ACI 0.1, project: $PROJECT_NAME$TAIL\n"

get_project_yml_flag SUCCESS MSG
printf "$MSG\n"

if [[ $SUCCESS = true ]]; then
    printf " ---$YML_PATH---\n"
    cat "$YML_PATH"
    printf " ---------------------------\n"
    printf "Updating arduino-cli index file\n    make sure you are connecting to the Internet\n"
    update
else
    

    
    read -p "Do you want to generate $PROJECT_NAME.yml (Y/n)?" choice
    case "$choice" in 
    n|N ) deactivate;;
    y|Y|* ) gen_project_yml SUCCESS MSG;;
    esac

    printf "    $MSG\n"

    if [[ $SUCCESS = true ]]; then
        printf " ---$YML_PATH---\n"
        cat "$YML_PATH"
        printf " ---------------------------\n"
        printf "Updating arduino index file, may take a while\n"
        update
    fi
fi
